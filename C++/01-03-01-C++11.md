---
layout: post
category: prepare
title: C++11新标准-01-20
tagline: by 阿秀
tags:
  - 原创
  - C++
  - CPP
  - 社招
  - 校招
  - 阿秀
excerpt: C++11新标准
comment: false
---

<h1 align="center">C++11新标准</h1>

## 1、C++ 11 有哪些新特性？

- nullptr 替代 NULL
- 引入了 auto 和 decltype 这两个关键字实现了类型推导
- 基于范围的 for 循环 for(auto& i : res){}
- 类和结构体的中初始化列表
- Lambda 表达式（匿名函数）
- std::forward_list（单向链表）
- 右值引用和 move 语义

* ...

<p id="autodecltype和decltypeauto的用法"></p>

## 2、auto、decltype 和 decltype(auto)的用法

**（1）auto**

C++11 新标准引入了 auto 类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应某种特定的类型说明符(例如 int)不同，

**auto 让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值。**

举个例子：

```cpp
//普通；类型
int a = 1, b = 3;
auto c = a + b;// c为int型

//const类型
const int i = 5;
auto j = i; // 变量i是顶层const, 会被忽略, 所以j的类型是int
auto k = &i; // 变量i是一个常量, 对常量取地址是一种底层const, 所以k的类型是const int*
const auto l = i; //如果希望推断出的类型是顶层const的, 那么就需要在auto前面加上cosnt

//引用和指针类型
int x = 2;
int& y = x;
auto z = y; //z是int型不是int& 型
auto& p1 = y; //p1是int&型
auto p2 = &x; //p2是指针类型int*
```

**（2）decltype**

有的时候我们还会遇到这种情况，**我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。**还有可能是函数的返回类型为某表达式的值类型。在这些时候 auto 显得就无力了，所以 C++11 又引入了第二种类型说明符 decltype，**它的作用是选择并返回操作数的数据类型。在此过程中，编译器只是分析表达式并得到它的类型，却不进行实际的计算表达式的值。**

```cpp
int func() {return 0};

//普通类型
decltype(func()) sum = 5; // sum的类型是函数func()的返回值的类型int, 但是这时不会实际调用函数func()
int a = 0;
decltype(a) b = 4; // a的类型是int, 所以b的类型也是int

//不论是顶层const还是底层const, decltype都会保留
const int c = 3;
decltype(c) d = c; // d的类型和c是一样的, 都是顶层const
int e = 4;
const int* f = &e; // f是底层const
decltype(f) g = f; // g也是底层const

//引用与指针类型
//1. 如果表达式是引用类型, 那么decltype的类型也是引用
const int i = 3, &j = i;
decltype(j) k = 5; // k的类型是 const int&

//2. 如果表达式是引用类型, 但是想要得到这个引用所指向的类型, 需要修改表达式:
int i = 3, &r = i;
decltype(r + 0) t = 5; // 此时是int类型

//3. 对指针的解引用操作返回的是引用类型
int i = 3, j = 6, *p = &i;
decltype(*p) c = j; // c是int&类型, c和j绑定在一起

//4. 如果一个表达式的类型不是引用, 但是我们需要推断出引用, 那么可以加上一对括号, 就变成了引用类型了
int i = 3;
decltype((i)) j = i; // 此时j的类型是int&类型, j和i绑定在了一起
```

**（3）decltype(auto)**

decltype(auto)是 C++14 新增的类型指示符，可以用来声明变量以及指示函数返回类型。在使用时，会将“=”号右边的表达式替换掉 auto，再根据 decltype 的语法规则来确定类型。举个例子：

```cpp
int e = 4;
const int* f = &e; // f是底层const
decltype(auto) j = f;//j的类型是const int* 并且指向的是e
```

<p id="nullptr区别"></p>

## 3、C++中 NULL 和 nullptr 区别

算是为了与 C 语言进行兼容而定义的一个问题吧

NULL 来自 C 语言，一般由宏定义实现，而 nullptr 则是 C++11 的新增关键字。

在 C 语言中，NULL 被定义为(void\*)0,而在 C++语言中，NULL 则被定义为整数 0。编译器一般对其实际定义如下：

```cpp
#ifdef __cplusplus
#define NULL 0
#else
#define NULL ((void *)0)
#endif
```

在 C++中指针必须有明确的类型定义。但是将 NULL 定义为 0 带来的另一个问题是无法与整数的 0 区分。因为 C++中允许有函数重载，所以可以试想如下函数定义情况：

```cpp
#include <iostream>
using namespace std;

void fun(char* p) {
	cout << "char*" << endl;
}

void fun(int p) {
	cout << "int" << endl;
}

int main()
{
	fun(NULL);
	return 0;
}
//输出结果：int
```

那么**在传入 NULL 参数时，会把 NULL 当做整数 0 来看，如果我们想调用参数是指针的函数，该怎么办呢?。nullptr 在 C++11 被引入用于解决这一问题，nullptr 可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。**

nullptr 的一种实现方式如下：

```cpp
const class nullptr_t{
public:
    template<class T>  inline operator T*() const{ return 0; }
    template<class C, class T> inline operator T C::*() const { return 0; }
private:
    void operator&() const;
} nullptr = {};
```

以上通过模板类和运算符重载的方式来对不同类型的指针进行实例化从而解决了(void\*)指针带来参数类型不明的问题，**另外由于 nullptr 是明确的指针类型，所以不会与整形变量相混淆。**但 nullptr 仍然存在一定问题，例如：

```cpp
#include <iostream>
using namespace std;

void fun(char* p)
{
	cout<< "char* p" <<endl;
}
void fun(int* p)
{
	cout<< "int* p" <<endl;
}

void fun(int p)
{
	cout<< "int p" <<endl;
}
int main()
{
    fun((char*)nullptr);//语句1
	fun(nullptr);//语句2
    fun(NULL);//语句3
    return 0;
}
//运行结果：
//语句1：char* p
//语句2:报错，有多个匹配
//3：int p
```

在这种情况下存在对不同指针类型的函数重载，此时如果传入 nullptr 指针则仍然存在无法区分应实际调用哪个函数，这种情况下必须显示的指明参数类型。

<p id="智能指针的原理、常用的智能指针及实现"></p>

## 4、智能指针的原理、常用的智能指针及实现

**原理**

智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源

**常用的智能指针**

**(1) shared_ptr**

实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加 1，每当减少一个智能指针指向对象时，引用计数会减 1，当计数为 0 的时候会自动的释放动态分配的资源。

- 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针
- 每次创建类的新对象时，初始化指针并将引用计数置为 1
- 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数
- 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至 0，则删除对象），并增加右操作数所指对象的引用计数
- 调用析构函数时，构造函数减少引用计数（如果引用计数减至 0，则删除基础对象）

**(2) unique_ptr**

unique_ptr 采用的是独享所有权语义，一个非空的 unique_ptr 总是拥有它所指向的资源。转移一个 unique_ptr 将会把所有权全部从源指针转移给目标指针，源指针被置空；所以 unique_ptr 不支持普通的拷贝和赋值操作，不能用在 STL 标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；如果你拷贝一个 unique_ptr，那么拷贝结束后，这两个 unique_ptr 都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

**(3) weak_ptr**

weak_ptr：弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用 weak_ptr 打破环形引用。weak_ptr 是一个弱引用，它是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被 shared_ptr 和 weak_ptr 同时引用，当所有 shared_ptr 析构了之后，不管还有没有 weak_ptr 引用该内存，内存也会被释放。所以 weak_ptr 不保证它指向的内存一定是有效的，在使用之前使用函数 lock()检查 weak_ptr 是否为空指针。

**(4) auto_ptr**

主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

auto_ptr 有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而 unique_ptr 则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用 std::move()进行转移。

auto_ptr 不支持拷贝和赋值操作，不能用在 STL 标准容器中。STL 容器中的元素经常要支持拷贝、赋值操作，在这过程中 auto_ptr 会传递所有权，所以不能在 STL 中使用。

**智能指针 shared_ptr 代码实现：**

```cpp
template<typename T>
class SharedPtr
{
public:
	SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))
	{}

	SharedPtr(const SharedPtr& s):_ptr(s._ptr), _pcount(s._pcount){
		(*_pcount)++;
	}

	SharedPtr<T>& operator=(const SharedPtr& s){
		if (this != &s)
		{
			if (--(*(this->_pcount)) == 0)
			{
				delete this->_ptr;
				delete this->_pcount;
			}
			_ptr = s._ptr;
			_pcount = s._pcount;
			(*_pcount)++;
		}
		return *this;
	}
	T& operator*()
	{
		return *(this->_ptr);
	}
	T* operator->()
	{
		return this->_ptr;
	}
	~SharedPtr()
	{
		--(*(this->_pcount));
		if (*(this->_pcount) == 0)
		{
			delete _ptr;
			_ptr = NULL;
			delete _pcount;
			_pcount = NULL;
		}
	}
private:
	T* _ptr;
	int* _pcount;//指向引用计数的指针
};
```

<p id="说一说你了解的关于lambda函数的全部知识"></p>

## 5、说一说你了解的关于 lambda 函数的全部知识

1. 利用 lambda 表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；

2. 每当你定义一个 lambda 表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个 lambda 表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的 lambda 表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为 lambda 捕捉块。

3. lambda 表达式的语法定义如下：

```cpp
[capture] （parameters） mutable ->return-type {statement};
```

4. lambda 必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；

> update1:微信好友“健康哥”指出代码实现部分笔误，感谢。

<p id="智能指针的作用"></p>

## 6、智能指针的作用

1.  C++11 中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

2.  智能指针在 C++11 版本之后提供，包含在头文件\<memory>中，shared_ptr、unique_ptr、weak_ptr。shared_ptr 多个指针指向相同的对象。shared_ptr 使用引用计数，每一个 shared_ptr 的拷贝都指向相同的内存。每使用他一次，内部的引用计数加 1，每析构一次，内部的引用计数减 1，减为 0 时，自动删除所指向的堆内存。shared_ptr 内部的引用计数是线程安全的，但是对象的读取需要加锁。

3.  初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用 make_shared 函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如 std::shared_ptr\<int> p4 = new int(1);的写法是错误的

拷贝和赋值。拷贝使得对象的引用计数增加 1，赋值使得原对象引用计数减 1，当计数为 0 时，自动释放内存。后来指向的对象引用计数加 1，指向后来的对象

4.  unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个 unique_ptr 指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针 unique_ptr 用于其 RAII 的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr 指针本身的生命周期：从 unique_ptr 指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用 delete 操作符，用户可指定其他操作)。unique_ptr 指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过 reset 方法重新指定、通过 release 方法释放所有权、通过移动语义转移所有权。

5.  智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为 1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至 0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至 0，则删除基础对象）。

6.  weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr 只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少.

<p  id="说说你了解的autoptr作用"></p>

## 7、说说你了解的 auto_ptr 作用

1.  auto_ptr 的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针 p 所指向的空间得不到释放而导致内存泄漏；

2.  auto_ptr 构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个 auto_ptr\<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；

3.  auto_ptr 的构造函数是 explicit，阻止了一般指针隐式转换为 auto_ptr 的构造，所以不能直接将一般类型的指针赋值给 auto_ptr 类型的对象，必须用 auto_ptr 的构造函数创建对象；

4.  由于 auto_ptr 对象析构时会删除它所拥有的指针，所以使用时避免多个 auto_ptr 对象管理同一个指针；

5.  Auto_ptr 内部实现，析构函数中删除对象用的是 delete 而不是 delete[]，所以 auto_ptr 不能管理数组；

6.  auto_ptr 支持所拥有的指针类型之间的隐式类型转换。

7.  可以通过\*和->运算符对 auto_ptr 所有用的指针进行提领操作；

8.  T* get(),获得 auto_ptr 所拥有的指针；T* release()，释放 auto_ptr 的所有权，并将所有用的指针返回。

<p  id="智能指针的循环引用"></p>

## 8、智能指针的循环引用

循环引用是指使用多个智能指针 share_ptr 时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：

```cpp
#include <iostream>
using namespace std;

template <typename T>
class Node
{
public:
	Node(const T& value)
		:_pPre(NULL)
		, _pNext(NULL)
		, _value(value)
	{
		cout << "Node()" << endl;
	}
	~Node()
	{
		cout << "~Node()" << endl;
		cout << "this:" << this << endl;
	}

	shared_ptr<Node<T>> _pPre;
	shared_ptr<Node<T>> _pNext;
	T _value;
};

void Funtest()
{
	shared_ptr<Node<int>> sp1(new Node<int>(1));
	shared_ptr<Node<int>> sp2(new Node<int>(2));

	cout << "sp1.use_count:" << sp1.use_count() << endl;
	cout << "sp2.use_count:" << sp2.use_count() << endl;

	sp1->_pNext = sp2; //sp2的引用+1
	sp2->_pPre = sp1; //sp1的引用+1

	cout << "sp1.use_count:" << sp1.use_count() << endl;
	cout << "sp2.use_count:" << sp2.use_count() << endl;
}
int main()
{
	Funtest();
	system("pause");
	return 0;
}
//输出结果
//Node()
//Node()
//sp1.use_count:1
//sp2.use_count:1
//sp1.use_count:2
//sp2.use_count:2
```

从上面 shared_ptr 的实现中我们知道了只有当引用计数减减之后等于 0，析构时才会释放对象，而上述情况造成了一个僵局，那就是析构对象时先析构 sp2,可是由于 sp2 的空间 sp1 还在使用中，所以 sp2.use_count 减减之后为 1，不释放，sp1 也是相同的道理，由于 sp1 的空间 sp2 还在使用中，所以 sp1.use_count 减减之后为 1，也不释放。sp1 等着 sp2 先释放，sp2 等着 sp1 先释放,二者互不相让，导致最终都没能释放，内存泄漏。

在实际编程过程中，应该尽量避免出现智能指针之前相互指向的情况，如果不可避免，可以使用使用弱指针——weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。

> 感谢网友勘误：https://github.com/forthespada/InterviewGuide/issues/11，注释错误，现已改正。- 2021.09.03

<p  id="手写实现智能指针类需要实现哪些函数"></p>

## 9、手写实现智能指针类需要实现哪些函数？

1.  智能指针是一个数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录 SmartPointer<T\*>对象的引用计数，一旦 T 类型对象的引用计数为 0，就释放该对象。

除了指针对象外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为 1，需要一个构造函数。新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存。

通过覆写赋值运算符，才能将一个旧的智能指针赋值给另一个指针，同时旧的引用计数减 1，新的引用计数加 1

2.  一个构造函数、拷贝构造函数、复制构造函数、析构函数、移动函数；

<p  id="智能指针出现循环引用怎么解决"></p>

## 10、智能指针出现循环引用怎么解决？

弱指针用于专门解决 shared_ptr 循环引用的问题，weak_ptr 不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个 shared_ptr 成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存。
